/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap_utils4.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ahmaymou <ahmaymou@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/12/21 11:57:31 by ahmaymou          #+#    #+#             */
/*   Updated: 2022/12/27 15:14:57 by ahmaymou        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

# include "push_swap.h"

void    scan_a(t_vars *vars)
{
    t_list  *temp;
    int     i;
    int     j;
    bool    first;
    bool    in_chunk;

    i = 0;
    j = i + 20;
    vars->hold_second_index = UINT_MAX;
    in_chunk = false;
    first = true;
    while (j < 100)
    {
        temp = vars->stack_a;
        i += 20;
        j += i;
        set_holds(vars, temp, i, j, first, in_chunk);
    }
}

void    set_holds(t_vars *vars, t_list *temp, int i, int j, bool first , bool in_chunk)
{
    while (1)
    {
        temp = vars->stack_a;
        in_chunk = false;
        while (temp)
        {
            if (temp->content < j && temp->content >= i)
            {
                if (first)
                {
                    vars->hold_first_index = temp->index;
                    first = false;
                    in_chunk = true;
                }
                if (vars->hold_second_index != temp->index && !first)
                {
                    vars->hold_second_index = temp->index;
                    in_chunk = true;
                }
            }
            temp = temp->next;
        }
        if (in_chunk)
            best_to_top_pb(vars);
        else
            break ;
    }
}

void    best_to_top_pb(t_vars *vars)
{
    if (vars->hold_first_index < vars->size_a / 2)
        vars->best_elem_index = vars->hold_first_index;
    else
        vars->best_elem_index = vars->hold_second_index;
    if (vars->best_elem_index == 2)
			sb(vars, 1);
		if (vars->best_elem_index < vars->size_a / 2)
			while (vars->best_elem_index--)
				ra(vars, 1);
	else
		while (vars->best_elem_index < vars->size_a)
            {
			    rra(vars, 1);
                vars->best_elem_index++;
            }
    pb(vars, 1);
}

void	do_pa(t_vars *vars)
{
	int				index;
	t_list			*temp1;
	int				temp;
	int				index2;
	unsigned int	max_i;

	set_best_elem_index(vars);
	temp1 = find_elem(vars, vars->best_elem_index, 'b');
	index = get_index_pos(vars, temp1);
	index2 = vars->best_elem_index;
	max_i = vars->size_a - 1;
	temp = 0;
	if (index2 >= 0)
	{
		while (index2--)
			rb(vars, 1);
	}
	else
	{
		index2 = abs_val(index2);
		if ((int)vars->size_b > index2 + 1)
			index2 = vars->size_b - index2;
		else
			index2 = 1;
		while (index2--)
			rrb(vars, 1);
	}
	if (index < 0)
	{
		index = abs_val(index);
		while (index <= (int)max_i)
		{
			rra(vars, 1);
			max_i--;
			temp++;
		}
		temp++;
		pa(vars, 1);
		// while (temp--)
		// 	ra(vars, 1);
	}
	else
	{
		temp = index;
		while (index--)
			ra(vars, 1);
		pa(vars, 1);
		// while (temp--)
		// 	rra(vars, 1);
	}
	// printf("[%d]\n", vars->max_a_index);
	// pa(vars, 1);
}